---
title: "Flight summary"
date:  "`r format(Sys.time(), '%d %B, %Y')`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
options(qwraps2_markup = "markdown")
library(tidyverse)
library(readr)
library(qwraps2)
library(Kulan)
library(ggpubr)
library(geosphere)
library(leaflet)
library(here)
```

## Flight summary template

This is a RMarkdown template. You can replace the text to suite your needs. You can also adapt the code to your own data. The idea behind this template is to simplify and standardise the process of generating a report summarising key aspects of the drone flight. 

RMarkdown is a format that allows you to write text and incorporate that with code or the outputs of code. To add code you need to write R code in a codeblock which can be added by clicking on the "insert" tab above and selecting "R". In addition you can add "inline" R code so that objects created in R are presented in the text. Here is a very quick example:

Insert a code block:

```{r This is a code block and you can write R code in it, echo=FALSE, warning=FALSE, message=FALSE}
# The R code goes here. 
D1=4
D2=2

D1+D2

```
In each code block you need a header between the curly brackets "{}" that starts with "r". Then you can add a title like I have done above or you can leave this blank. Importantly after this title (which needs to be unique for each code block) you need a "," and then you can tell RMarkdown what you want it to do with the code. There are many different commands but the most useful is "echo" which if "echo=TRUE" will print the code in the output. I tend to add "warning=FALSE, message=FALSE" to the code blocks to reduce R package warnings. 

To use the object created in the code block you can use "inline" code. So for example we can write: 4 + 2 = `r D1+D2 `. This will print out the sum of object D1 and D2 created in the code block inside the text.

To create a "report" once you are happy with the text and code in the RMarkdown document you can click on the "knit" button. This will run all the code blocks and then will create an output (currently set to a html file but there is an option for pdf or word. html is the most flexible format and works more naturally with R code, you may need to change some of the plotting functions to get them to look good in pdf format, for example). At any point you can also run the code in a block by clicking on the green button at the top of the code block. You can run all code blocks by clicking on run in the menu at the top of the page. It is important to remember that the code blocks are run sequentially so if you create an object in the second codeblock you could not make use of it until after that codeblock has run. 

## Gather all the Flights in to a single dataset

```{r make a large dataset, echo=TRUE, message=FALSE, warning=FALSE}
library(here)
#here::here()
path=paste0(here::here(),"/", "data/tables")
#list.files(path)
all_dfs=Kulan::get_tables(path, ".csv")
all_dfs=all_dfs %>% 
  janitor::clean_names() %>% 
  rename(., Flight = class)


```

## Draw the flight paths for all flights

```{r}
library(leaflet)
pal <- colorFactor(
  palette = 'Dark2',
  domain = all_dfs$Flight
)


leaflet(data=all_dfs[,c(5,4, 18)]) %>% 
  addTiles() %>% 
  addCircleMarkers(lng=~lon_dec, lat=~lat_dec, radius=2, color = ~pal(Flight))
```


## Draw the flight paths for each flight

```{r}
library(leaflet)
ldat1=all_dfs %>% 
  filter(Flight=="Flight1")
leaflet(data=ldat1[,c(5,4)]) %>% 
  addTiles() %>% 
  addCircleMarkers(lng=~lon_dec, lat=~lat_dec, radius=2)
```

```{r}
library(leaflet)
ldat1=all_dfs %>% 
  filter(Flight=="Flight2")
leaflet(data=ldat1[,c(5,4)]) %>% 
  addTiles() %>% 
  addCircleMarkers(lng=~lon_dec, lat=~lat_dec, radius=2)
```


```{r}
library(leaflet)
ldat1=all_dfs %>% 
  filter(Flight=="Flight3")
leaflet(data=ldat1[,c(5,4)]) %>% 
  addTiles() %>% 
  addCircleMarkers(lng=~lon_dec, lat=~lat_dec, radius=2)
```



```{r}
library(leaflet)
ldat1=all_dfs %>% 
  filter(Flight=="Flight4")
leaflet(data=ldat1[,c(5,4)]) %>% 
  addTiles() %>% 
  addCircleMarkers(lng=~lon_dec, lat=~lat_dec, radius=2)
```


```{r}
library(leaflet)
ldat1=all_dfs %>% 
  filter(Flight=="Flight5")
leaflet(data=ldat1[,c(5,4)]) %>% 
  addTiles() %>% 
  addCircleMarkers(lng=~lon_dec, lat=~lat_dec, radius=2)
```



```{r}
library(leaflet)
ldat1=all_dfs %>% 
  filter(Flight=="Flight6")
leaflet(data=ldat1[,c(5,4)]) %>% 
  addTiles() %>% 
  addCircleMarkers(lng=~lon_dec, lat=~lat_dec, radius=2)
```


```{r}
library(leaflet)
ldat1=all_dfs %>% 
  filter(Flight=="Flight7")
leaflet(data=ldat1[,c(5,4)]) %>% 
  addTiles() %>% 
  addCircleMarkers(lng=~lon_dec, lat=~lat_dec, radius=2)
```



```{r}
library(leaflet)
ldat1=all_dfs %>% 
  filter(Flight=="Flight8")
leaflet(data=ldat1[,c(5,4)]) %>% 
  addTiles() %>% 
  addCircleMarkers(lng=~lon_dec, lat=~lat_dec, radius=2)
```


At this point you could add the altitude from the DEM [see the "Getting raster values form a Digital Elevation Model" vignette]. Here, for this example, we will use the column called Altitude above the ground (*because we can not include all the DEMs we would need inside the package*).

## Strip-width summary

```{r, results='asis', echo=TRUE, message=FALSE, warning=FALSE}
 all_dfs=all_dfs%>% 
    group_by(Flight) %>%
  filter(!str_detect(photo_no, "IMG")) %>% # remove empty photos
  rowwise() %>% 
  mutate("strip_width"=get_strip_width(alt=alt_above_ground,banking_angle = banking_angle)) %>% 
  drop_na(strip_width)
 our_summary1 <-
  list("strip width" =
         list("min"       = ~ round(min(strip_width)),
              "max"       = ~ round(max(strip_width)),
              "mean (sd)" = ~qwraps2::mean_sd(strip_width)))


tab_1<-qwraps2::summary_table(dplyr::group_by(all_dfs, Flight),our_summary1)
tab_1

```

## Remove points where the drone is in take-off or landing

### First plot the data

```{r}
all_dfs %>% 
  mutate(time2=as.POSIXct(time,format="%H:%M:%S")) %>% 
  ggplot(aes(time2, alt_above_ground, colour=Flight))+ 
  geom_point()+
  labs(x="time",y= "Altitude above ground")+
  theme(legend.position = "None")+
  facet_wrap(~Flight)

```

From the distribution of the altitudes we can see that anything below 200 m is probably take-off or landing phase. 

```{r}
all_dfs %>% 
  ggplot(aes(alt_above_ground))+
  geom_histogram(fill="Red")
```

However, we might want to look more closely at Flight5 as it seems some of the points during the flight are below 200m.

```{r}
all_dfs %>% 
  filter(Flight=="Flight5") %>% 
  ggplot(aes(time, alt_above_ground, colour=Flight)) +
  labs(y= "Altitude above sea level")+
  theme(axis.text.x = element_blank())+
  geom_point()+
  geom_hline(yintercept = 200, colour="Red", lty=2) +
  geom_hline(yintercept = 190, colour="Green", lty=2) +
  theme(legend.position = "None")

```

So a couple of points in Flight5 during the actual flight were below our threshold of 200m. So let's be conservative and go for 190m instead. You can change this threshold by changing the value in the code below.

```{r}
all_dfs_reduced=all_dfs %>% 
  filter(alt_above_ground>190)# The threshold is controlled here - change it by changing the number from 190
```

Now all the points in consideration are above 190m.Let's re-run the strip-width summary.

```{r, results='asis', echo=FALSE,, message=FALSE, warning=FALSE}
all_dfs_reduced=all_dfs_reduced%>% 
    group_by(Flight) %>%
  filter(!str_detect(photo_no, "IMG")) %>% # remove empty photos
  rowwise() %>% 
  mutate("strip_width"=Kulan::get_strip_width(alt=alt_above_ground, banking_angle = banking_angle))
 our_summary2 <-
  list("strip width" =
         list("min"       = ~ round(min(strip_width)),
              "max"       = ~ round(max(strip_width)),
              "mean (sd)" = ~ qwraps2::mean_sd(strip_width)))


tab_1<-qwraps2::summary_table(dplyr::group_by(all_dfs_reduced, Flight),our_summary2)
tab_1

```
## Altitude above ground summary

```{r}
all_dfs_reduced %>% 
   mutate(time2=as.POSIXct(time,format="%H:%M:%S")) %>% 
  ggplot(aes(time2,alt_above_ground))+
  geom_point(colour="darkblue")+
  geom_line(colour="darkblue")+
  labs(x="time", y="Altitude above the ground")+
  facet_wrap(Flight~., scale="free")

```


## Speed summary

Using the gps_speed we can plot the speed of the drone during each flight.

```{r}

all_dfs_reduced%>% 
  mutate(rowid=row_number()) %>% 
  mutate(time2=as.POSIXct(time,format="%H:%M:%S")) %>% 
  #ggplot(aes(time2,gps_speed))+# replace the next line with this to remove the alt_above_ground colour
  ggplot(aes(time2,gps_speed,colour=alt_above_ground))+
  geom_point()+
  geom_line()+
  labs(x="time", y="gps speed")+
  #geom_point(colour="darkblue")+# add these lines too and remove the two above
  #geom_line(colour="darkblue")+#
  facet_wrap(~Flight, scales="free")
```

## Distance between points summary

There are some very large distances moved at the start or the end of a Flight and these need to be filtered out to allow us to plot the distance more clearly. Anything above 250m is therefore removed in the plotting code below.The points are coloured by the gps_speed. 

```{r}
distance_df=all_dfs_reduced%>% 
  group_by(Flight) %>% 
  mutate(new_lat=lag(lat_dec)) %>%
  mutate(new_lon=lag(lon_dec)) %>%
  rowwise() %>%
  mutate(coord_dif=distm(c(lon_dec, lat_dec), c(new_lon, new_lat), fun = distHaversine))

distance_df %>% 
  group_by(Flight) %>% 
   mutate(time2=as.POSIXct(time,format="%H:%M:%S")) %>% 
  filter(coord_dif<250) %>% 
  ggplot(aes(time2,coord_dif,colour=gps_speed))+
  geom_point()+
  geom_line()+
  scale_colour_gradientn(colours = terrain.colors(10))+
  labs(x="time",y="distance (m) between points")+
  facet_wrap(~Flight, scales="free")
```

## Banking Angle


```{r}
all_dfs_reduced%>% 
  mutate(rowid=row_number()) %>% 
  mutate(time2=as.POSIXct(time,format="%H:%M:%S")) %>% 
  ggplot(aes(time2,banking_angle))+
  geom_point(colour="darkblue")+
  geom_line(colour="darkblue")+
  labs(x="time", y="Banking angle")+
  facet_wrap(~Flight, scales="free")
```

## Photograph area

```{r}
all_dfs_reduced=all_dfs_reduced %>% 
  rowwise() %>% 
  mutate("photo_area"=Kulan::get_photo_area(altitude = alt_above_ground,banking_angle = banking_angle))


all_dfs_reduced %>% 
  dplyr::select(photo_area) %>% 
  ggplot(aes(photo_area))+
  labs(x="photograph area m2")+
  geom_histogram(fill="red")+
  theme_classic()
```
## Overlap

The forward overlap is the percentage overlap that two consecutive images have. To calculate this value we could not use a single function so have developed a script to follow the process. This is hidden here in the rendered Markdown but contained in the script.

```{r, echo=FALSE}
overlap_df=distance_df %>% 
  select(photo_no, alt_above_ground, coord_dif, banking_angle, Flight)

overlap_df$altitude1=overlap_df$alt_above_ground
overlap_df$altitude2=lead(overlap_df$altitude1)
overlap_df$distance=overlap_df$coord_dif
overlap_df$banking_angle1=overlap_df$banking_angle
overlap_df$banking_angle2=lead(overlap_df$banking_angle1)


overlap_df1=overlap_df %>%
  filter(Flight=="Flight1")

overlap_df1$forward_overlap=rep(NA,dim(overlap_df1)[1])


for (i in 2:dim(overlap_df1)[1]){

  altitude1=overlap_df1$altitude1[i]
  altitude2=overlap_df1$altitude2[i]
  forward_distance=overlap_df1$distance[i]
  angle_of_camera=25
  banking_angle1=overlap_df1$banking_angle1[i]
  banking_angle2=overlap_df1$banking_angle2[i]



  #Picture1
  h1=altitude1
  # angle of camera1
  theta1 <- Kulan::deg_to_rad(angle_of_camera)
  # horizontal field of view
  phi1 <- Kulan::deg_to_rad(Kulan::get_HFOV()+banking_angle1)
  # vertical field of view
  omega1 <- Kulan::deg_to_rad(Kulan::get_VFOV())
  Dc1= h1*tan(theta1-phi1/2)
  Df1= h1*tan(theta1+phi1/2)
  Dm1= h1*tan(theta1+phi1*0.5/2)
  Rc1=sqrt(h1^2+Dc1^2)
  Rm1=sqrt(h1^2+Dm1^2)
  Rf1=sqrt(h1^2+Df1^2)

  #Picture2
  h2=altitude2
  # angle of camera2
  theta2 <- Kulan::deg_to_rad(angle_of_camera)
  # horizontal field of view
  phi2 <- Kulan::deg_to_rad(Kulan::get_HFOV()+banking_angle2)
  # vertical field of view
  omega2 <- Kulan::deg_to_rad(Kulan::get_VFOV())
  Dc2= h2*tan(theta2-phi2/2)
  Df2= h2*tan(theta2+phi2/2)
  Dm2= h2*tan(theta2+phi2*0.5/2)
  Rc2=sqrt(h2^2+Dc2^2)
  Rm2=sqrt(h2^2+Dm2^2)
  Rf2=sqrt(h2^2+Df2^2)

  #Work out overlap between trapezoids
  Wc1=2*(Dc1^2+h1^2)^0.5*tan(omega1/2)
  Wm1=2*((Dc1+Df1/2)^2+h1^2)^0.5*tan(omega1/2)
  Wf1=2*(Df1^2+h1^2)^0.5*tan(omega1/2)
  positions1 <- data.frame(
    x = c(0, 0, Df1-Dc1, Df1-Dc1),
    y = c(-Wc1/2, Wc1/2, -Wf1/2, Wf1/2)
  )

  Wc2=2*(Dc2^2+h2^2)^0.5*tan(omega2/2)
  Wm2=2*((Dc2+Df2/2)^2+h2^2)^0.5*tan(omega2/2)
  Wf2=2*(Df2^2+h2^2)^0.5*tan(omega2/2)
  positions2 <- data.frame(
    x = c(0, 0, Df2-Dc2, Df2-Dc2),
    y = c(-Wc2/2+forward_distance, Wc2/2+forward_distance,
          -Wf2/2+forward_distance, Wf2/2+forward_distance)
  )

  library(sp)
  p = Polygon(positions1[c(1,2,4,3),] )
  ps = Polygons(list(p),1)
  sps = SpatialPolygons(list(ps))
  p2 = Polygon(positions2[c(1,2,4,3),] )
  ps2 = Polygons(list(p2),1)
  sps2 = SpatialPolygons(list(ps2))
  #plot(rgeos::gIntersection(sps,sps2), add=TRUE)
  area=rgeos::gIntersection(sps,sps2)
  if(is.null(area)){
    overlap_df1$forward_overlap[i]=0
  }else{
  overlap_df1$forward_overlap[i]=area@polygons[[1]]@area
  }
}
overlap_df1$forward_overlap

###############################################################

overlap_df2=overlap_df %>%
  filter(Flight=="Flight2")

overlap_df2$forward_overlap=rep(NA,dim(overlap_df2)[1])


for (i in 2:dim(overlap_df2)[1]){

  altitude1=overlap_df2$altitude1[i]
  altitude2=overlap_df2$altitude2[i]
  forward_distance=overlap_df2$distance[i]
  angle_of_camera=25
  banking_angle1=overlap_df2$banking_angle1[i]
  banking_angle2=overlap_df2$banking_angle2[i]



  #Picture1
  h1=altitude1
  # angle of camera1
  theta1 <- Kulan::deg_to_rad(angle_of_camera)
  # horizontal field of view
  phi1 <- Kulan::deg_to_rad(Kulan::get_HFOV()+banking_angle1)
  # vertical field of view
  omega1 <- Kulan::deg_to_rad(Kulan::get_VFOV())
  Dc1= h1*tan(theta1-phi1/2)
  Df1= h1*tan(theta1+phi1/2)
  Dm1= h1*tan(theta1+phi1*0.5/2)
  Rc1=sqrt(h1^2+Dc1^2)
  Rm1=sqrt(h1^2+Dm1^2)
  Rf1=sqrt(h1^2+Df1^2)

  #Picture2
  h2=altitude2
  # angle of camera2
  theta2 <- Kulan::deg_to_rad(angle_of_camera)
  # horizontal field of view
  phi2 <- Kulan::deg_to_rad(Kulan::get_HFOV()+banking_angle2)
  # vertical field of view
  omega2 <- Kulan::deg_to_rad(Kulan::get_VFOV())
  Dc2= h2*tan(theta2-phi2/2)
  Df2= h2*tan(theta2+phi2/2)
  Dm2= h2*tan(theta2+phi2*0.5/2)
  Rc2=sqrt(h2^2+Dc2^2)
  Rm2=sqrt(h2^2+Dm2^2)
  Rf2=sqrt(h2^2+Df2^2)

  #Work out overlap between trapezoids
  Wc1=2*(Dc1^2+h1^2)^0.5*tan(omega1/2)
  Wm1=2*((Dc1+Df1/2)^2+h1^2)^0.5*tan(omega1/2)
  Wf1=2*(Df1^2+h1^2)^0.5*tan(omega1/2)
  positions1 <- data.frame(
    x = c(0, 0, Df1-Dc1, Df1-Dc1),
    y = c(-Wc1/2, Wc1/2, -Wf1/2, Wf1/2)
  )

  Wc2=2*(Dc2^2+h2^2)^0.5*tan(omega2/2)
  Wm2=2*((Dc2+Df2/2)^2+h2^2)^0.5*tan(omega2/2)
  Wf2=2*(Df2^2+h2^2)^0.5*tan(omega2/2)
  positions2 <- data.frame(
    x = c(0, 0, Df2-Dc2, Df2-Dc2),
    y = c(-Wc2/2+forward_distance, Wc2/2+forward_distance,
          -Wf2/2+forward_distance, Wf2/2+forward_distance)
  )

  library(sp)
  p = Polygon(positions1[c(1,2,4,3),] )
  ps = Polygons(list(p),1)
  sps = SpatialPolygons(list(ps))
  p2 = Polygon(positions2[c(1,2,4,3),] )
  ps2 = Polygons(list(p2),1)
  sps2 = SpatialPolygons(list(ps2))
  #plot(rgeos::gIntersection(sps,sps2), add=TRUE)
  area=rgeos::gIntersection(sps,sps2)
  if(is.null(area)){
    overlap_df2$forward_overlap[i]=0
  }else{
    overlap_df2$forward_overlap[i]=area@polygons[[1]]@area
  }
}
overlap_df2$forward_overlap

########################################################
overlap_df3=overlap_df %>%
  filter(Flight=="Flight3")

overlap_df3$forward_overlap=rep(NA,dim(overlap_df3)[1])


for (i in 2:dim(overlap_df3)[1]){

  altitude1=overlap_df3$altitude1[i]
  altitude2=overlap_df3$altitude2[i]
  forward_distance=overlap_df3$distance[i]
  angle_of_camera=25
  banking_angle1=overlap_df3$banking_angle1[i]
  banking_angle2=overlap_df3$banking_angle2[i]



  #Picture1
  h1=altitude1
  # angle of camera1
  theta1 <- Kulan::deg_to_rad(angle_of_camera)
  # horizontal field of view
  phi1 <- Kulan::deg_to_rad(Kulan::get_HFOV()+banking_angle1)
  # vertical field of view
  omega1 <- Kulan::deg_to_rad(Kulan::get_VFOV())
  Dc1= h1*tan(theta1-phi1/2)
  Df1= h1*tan(theta1+phi1/2)
  Dm1= h1*tan(theta1+phi1*0.5/2)
  Rc1=sqrt(h1^2+Dc1^2)
  Rm1=sqrt(h1^2+Dm1^2)
  Rf1=sqrt(h1^2+Df1^2)

  #Picture2
  h2=altitude2
  # angle of camera2
  theta2 <- Kulan::deg_to_rad(angle_of_camera)
  # horizontal field of view
  phi2 <- Kulan::deg_to_rad(Kulan::get_HFOV()+banking_angle2)
  # vertical field of view
  omega2 <- Kulan::deg_to_rad(Kulan::get_VFOV())
  Dc2= h2*tan(theta2-phi2/2)
  Df2= h2*tan(theta2+phi2/2)
  Dm2= h2*tan(theta2+phi2*0.5/2)
  Rc2=sqrt(h2^2+Dc2^2)
  Rm2=sqrt(h2^2+Dm2^2)
  Rf2=sqrt(h2^2+Df2^2)

  #Work out overlap between trapezoids
  Wc1=2*(Dc1^2+h1^2)^0.5*tan(omega1/2)
  Wm1=2*((Dc1+Df1/2)^2+h1^2)^0.5*tan(omega1/2)
  Wf1=2*(Df1^2+h1^2)^0.5*tan(omega1/2)
  positions1 <- data.frame(
    x = c(0, 0, Df1-Dc1, Df1-Dc1),
    y = c(-Wc1/2, Wc1/2, -Wf1/2, Wf1/2)
  )

  Wc2=2*(Dc2^2+h2^2)^0.5*tan(omega2/2)
  Wm2=2*((Dc2+Df2/2)^2+h2^2)^0.5*tan(omega2/2)
  Wf2=2*(Df2^2+h2^2)^0.5*tan(omega2/2)
  positions2 <- data.frame(
    x = c(0, 0, Df2-Dc2, Df2-Dc2),
    y = c(-Wc2/2+forward_distance, Wc2/2+forward_distance,
          -Wf2/2+forward_distance, Wf2/2+forward_distance)
  )

  library(sp)
  p = Polygon(positions1[c(1,2,4,3),] )
  ps = Polygons(list(p),1)
  sps = SpatialPolygons(list(ps))
  p2 = Polygon(positions2[c(1,2,4,3),] )
  ps2 = Polygons(list(p2),1)
  sps2 = SpatialPolygons(list(ps2))
  #plot(rgeos::gIntersection(sps,sps2), add=TRUE)
  area=rgeos::gIntersection(sps,sps2)
  if(is.null(area)){
    overlap_df3$forward_overlap[i]=0
  }else{
    overlap_df3$forward_overlap[i]=area@polygons[[1]]@area
  }
}
overlap_df3$forward_overlap

###########################################################

overlap_df4=overlap_df %>%
  filter(Flight=="Flight4")

overlap_df4$forward_overlap=rep(NA,dim(overlap_df4)[1])

for (i in 2:dim(overlap_df4)[1]){

  altitude1=overlap_df4$altitude1[i]
  altitude2=overlap_df4$altitude2[i]
  forward_distance=overlap_df4$distance[i]
  angle_of_camera=25
  banking_angle1=overlap_df4$banking_angle1[i]
  banking_angle2=overlap_df4$banking_angle2[i]



  #Picture1
  h1=altitude1
  # angle of camera1
  theta1 <- Kulan::deg_to_rad(angle_of_camera)
  # horizontal field of view
  phi1 <- Kulan::deg_to_rad(Kulan::get_HFOV()+banking_angle1)
  # vertical field of view
  omega1 <- Kulan::deg_to_rad(Kulan::get_VFOV())
  Dc1= h1*tan(theta1-phi1/2)
  Df1= h1*tan(theta1+phi1/2)
  Dm1= h1*tan(theta1+phi1*0.5/2)
  Rc1=sqrt(h1^2+Dc1^2)
  Rm1=sqrt(h1^2+Dm1^2)
  Rf1=sqrt(h1^2+Df1^2)

  #Picture2
  h2=altitude2
  # angle of camera2
  theta2 <- Kulan::deg_to_rad(angle_of_camera)
  # horizontal field of view
  phi2 <- Kulan::deg_to_rad(Kulan::get_HFOV()+banking_angle2)
  # vertical field of view
  omega2 <- Kulan::deg_to_rad(Kulan::get_VFOV())
  Dc2= h2*tan(theta2-phi2/2)
  Df2= h2*tan(theta2+phi2/2)
  Dm2= h2*tan(theta2+phi2*0.5/2)
  Rc2=sqrt(h2^2+Dc2^2)
  Rm2=sqrt(h2^2+Dm2^2)
  Rf2=sqrt(h2^2+Df2^2)

  #Work out overlap between trapezoids
  Wc1=2*(Dc1^2+h1^2)^0.5*tan(omega1/2)
  Wm1=2*((Dc1+Df1/2)^2+h1^2)^0.5*tan(omega1/2)
  Wf1=2*(Df1^2+h1^2)^0.5*tan(omega1/2)
  positions1 <- data.frame(
    x = c(0, 0, Df1-Dc1, Df1-Dc1),
    y = c(-Wc1/2, Wc1/2, -Wf1/2, Wf1/2)
  )

  Wc2=2*(Dc2^2+h2^2)^0.5*tan(omega2/2)
  Wm2=2*((Dc2+Df2/2)^2+h2^2)^0.5*tan(omega2/2)
  Wf2=2*(Df2^2+h2^2)^0.5*tan(omega2/2)
  positions2 <- data.frame(
    x = c(0, 0, Df2-Dc2, Df2-Dc2),
    y = c(-Wc2/2+forward_distance, Wc2/2+forward_distance,
          -Wf2/2+forward_distance, Wf2/2+forward_distance)
  )

  library(sp)
  p = Polygon(positions1[c(1,2,4,3),] )
  ps = Polygons(list(p),1)
  sps = SpatialPolygons(list(ps))
  p2 = Polygon(positions2[c(1,2,4,3),] )
  ps2 = Polygons(list(p2),1)
  sps2 = SpatialPolygons(list(ps2))
  #plot(rgeos::gIntersection(sps,sps2), add=TRUE)
  area=rgeos::gIntersection(sps,sps2)
  if(is.null(area)){
    overlap_df4$forward_overlap[i]=0
  }else{
    overlap_df4$forward_overlap[i]=area@polygons[[1]]@area
  }
}
overlap_df4$forward_overlap

###############################################################
overlap_df5=overlap_df %>%
  filter(Flight=="Flight5")

overlap_df5$forward_overlap=rep(NA,dim(overlap_df5)[1])


for (i in 2:dim(overlap_df5)[1]){

  altitude1=overlap_df5$altitude1[i]
  altitude2=overlap_df5$altitude2[i]
  forward_distance=overlap_df5$distance[i]
  angle_of_camera=25
  banking_angle1=overlap_df5$banking_angle1[i]
  banking_angle2=overlap_df5$banking_angle2[i]



  #Picture1
  h1=altitude1
  # angle of camera1
  theta1 <- Kulan::deg_to_rad(angle_of_camera)
  # horizontal field of view
  phi1 <- Kulan::deg_to_rad(Kulan::get_HFOV()+banking_angle1)
  # vertical field of view
  omega1 <- Kulan::deg_to_rad(Kulan::get_VFOV())
  Dc1= h1*tan(theta1-phi1/2)
  Df1= h1*tan(theta1+phi1/2)
  Dm1= h1*tan(theta1+phi1*0.5/2)
  Rc1=sqrt(h1^2+Dc1^2)
  Rm1=sqrt(h1^2+Dm1^2)
  Rf1=sqrt(h1^2+Df1^2)

  #Picture2
  h2=altitude2
  # angle of camera2
  theta2 <- Kulan::deg_to_rad(angle_of_camera)
  # horizontal field of view
  phi2 <- Kulan::deg_to_rad(Kulan::get_HFOV()+banking_angle2)
  # vertical field of view
  omega2 <- Kulan::deg_to_rad(Kulan::get_VFOV())
  Dc2= h2*tan(theta2-phi2/2)
  Df2= h2*tan(theta2+phi2/2)
  Dm2= h2*tan(theta2+phi2*0.5/2)
  Rc2=sqrt(h2^2+Dc2^2)
  Rm2=sqrt(h2^2+Dm2^2)
  Rf2=sqrt(h2^2+Df2^2)

  #Work out overlap between trapezoids
  Wc1=2*(Dc1^2+h1^2)^0.5*tan(omega1/2)
  Wm1=2*((Dc1+Df1/2)^2+h1^2)^0.5*tan(omega1/2)
  Wf1=2*(Df1^2+h1^2)^0.5*tan(omega1/2)
  positions1 <- data.frame(
    x = c(0, 0, Df1-Dc1, Df1-Dc1),
    y = c(-Wc1/2, Wc1/2, -Wf1/2, Wf1/2)
  )

  Wc2=2*(Dc2^2+h2^2)^0.5*tan(omega2/2)
  Wm2=2*((Dc2+Df2/2)^2+h2^2)^0.5*tan(omega2/2)
  Wf2=2*(Df2^2+h2^2)^0.5*tan(omega2/2)
  positions2 <- data.frame(
    x = c(0, 0, Df2-Dc2, Df2-Dc2),
    y = c(-Wc2/2+forward_distance, Wc2/2+forward_distance,
          -Wf2/2+forward_distance, Wf2/2+forward_distance)
  )

  library(sp)
  p = Polygon(positions1[c(1,2,4,3),] )
  ps = Polygons(list(p),1)
  sps = SpatialPolygons(list(ps))
  p2 = Polygon(positions2[c(1,2,4,3),] )
  ps2 = Polygons(list(p2),1)
  sps2 = SpatialPolygons(list(ps2))
  #plot(rgeos::gIntersection(sps,sps2), add=TRUE)
  area=rgeos::gIntersection(sps,sps2)
  if(is.null(area)){
    overlap_df5$forward_overlap[i]=0
  }else{
    overlap_df5$forward_overlap[i]=area@polygons[[1]]@area
  }
}
overlap_df5$forward_overlap

################################################################
overlap_df6=overlap_df %>%
  filter(Flight=="Flight6")

overlap_df6$forward_overlap=rep(NA,dim(overlap_df6)[1])


for (i in 2:dim(overlap_df6)[1]){

  altitude1=overlap_df6$altitude1[i]
  altitude2=overlap_df6$altitude2[i]
  forward_distance=overlap_df6$distance[i]
  angle_of_camera=25
  banking_angle1=overlap_df6$banking_angle1[i]
  banking_angle2=overlap_df6$banking_angle2[i]



  #Picture1
  h1=altitude1
  # angle of camera1
  theta1 <- Kulan::deg_to_rad(angle_of_camera)
  # horizontal field of view
  phi1 <- Kulan::deg_to_rad(Kulan::get_HFOV()+banking_angle1)
  # vertical field of view
  omega1 <- Kulan::deg_to_rad(Kulan::get_VFOV())
  Dc1= h1*tan(theta1-phi1/2)
  Df1= h1*tan(theta1+phi1/2)
  Dm1= h1*tan(theta1+phi1*0.5/2)
  Rc1=sqrt(h1^2+Dc1^2)
  Rm1=sqrt(h1^2+Dm1^2)
  Rf1=sqrt(h1^2+Df1^2)

  #Picture2
  h2=altitude2
  # angle of camera2
  theta2 <- Kulan::deg_to_rad(angle_of_camera)
  # horizontal field of view
  phi2 <- Kulan::deg_to_rad(Kulan::get_HFOV()+banking_angle2)
  # vertical field of view
  omega2 <- Kulan::deg_to_rad(Kulan::get_VFOV())
  Dc2= h2*tan(theta2-phi2/2)
  Df2= h2*tan(theta2+phi2/2)
  Dm2= h2*tan(theta2+phi2*0.5/2)
  Rc2=sqrt(h2^2+Dc2^2)
  Rm2=sqrt(h2^2+Dm2^2)
  Rf2=sqrt(h2^2+Df2^2)

  #Work out overlap between trapezoids
  Wc1=2*(Dc1^2+h1^2)^0.5*tan(omega1/2)
  Wm1=2*((Dc1+Df1/2)^2+h1^2)^0.5*tan(omega1/2)
  Wf1=2*(Df1^2+h1^2)^0.5*tan(omega1/2)
  positions1 <- data.frame(
    x = c(0, 0, Df1-Dc1, Df1-Dc1),
    y = c(-Wc1/2, Wc1/2, -Wf1/2, Wf1/2)
  )

  Wc2=2*(Dc2^2+h2^2)^0.5*tan(omega2/2)
  Wm2=2*((Dc2+Df2/2)^2+h2^2)^0.5*tan(omega2/2)
  Wf2=2*(Df2^2+h2^2)^0.5*tan(omega2/2)
  positions2 <- data.frame(
    x = c(0, 0, Df2-Dc2, Df2-Dc2),
    y = c(-Wc2/2+forward_distance, Wc2/2+forward_distance,
          -Wf2/2+forward_distance, Wf2/2+forward_distance)
  )

  library(sp)
  p = Polygon(positions1[c(1,2,4,3),] )
  ps = Polygons(list(p),1)
  sps = SpatialPolygons(list(ps))
  p2 = Polygon(positions2[c(1,2,4,3),] )
  ps2 = Polygons(list(p2),1)
  sps2 = SpatialPolygons(list(ps2))
  #plot(rgeos::gIntersection(sps,sps2), add=TRUE)
  area=rgeos::gIntersection(sps,sps2)
  if(is.null(area)){
    overlap_df6$forward_overlap[i]=0
  }else{
    overlap_df6$forward_overlap[i]=area@polygons[[1]]@area
  }
}
overlap_df6$forward_overlap
###############################################################
overlap_df7=overlap_df %>%
  filter(Flight=="Flight7")

overlap_df7$forward_overlap=rep(NA,dim(overlap_df7)[1])


for (i in 2:dim(overlap_df7)[1]){

  altitude1=overlap_df7$altitude1[i]
  altitude2=overlap_df7$altitude2[i]
  forward_distance=overlap_df7$distance[i]
  angle_of_camera=25
  banking_angle1=overlap_df7$banking_angle1[i]
  banking_angle2=overlap_df7$banking_angle2[i]



  #Picture1
  h1=altitude1
  # angle of camera1
  theta1 <- Kulan::deg_to_rad(angle_of_camera)
  # horizontal field of view
  phi1 <- Kulan::deg_to_rad(Kulan::get_HFOV()+banking_angle1)
  # vertical field of view
  omega1 <- Kulan::deg_to_rad(Kulan::get_VFOV())
  Dc1= h1*tan(theta1-phi1/2)
  Df1= h1*tan(theta1+phi1/2)
  Dm1= h1*tan(theta1+phi1*0.5/2)
  Rc1=sqrt(h1^2+Dc1^2)
  Rm1=sqrt(h1^2+Dm1^2)
  Rf1=sqrt(h1^2+Df1^2)

  #Picture2
  h2=altitude2
  # angle of camera2
  theta2 <- Kulan::deg_to_rad(angle_of_camera)
  # horizontal field of view
  phi2 <- Kulan::deg_to_rad(Kulan::get_HFOV()+banking_angle2)
  # vertical field of view
  omega2 <- Kulan::deg_to_rad(Kulan::get_VFOV())
  Dc2= h2*tan(theta2-phi2/2)
  Df2= h2*tan(theta2+phi2/2)
  Dm2= h2*tan(theta2+phi2*0.5/2)
  Rc2=sqrt(h2^2+Dc2^2)
  Rm2=sqrt(h2^2+Dm2^2)
  Rf2=sqrt(h2^2+Df2^2)

  #Work out overlap between trapezoids
  Wc1=2*(Dc1^2+h1^2)^0.5*tan(omega1/2)
  Wm1=2*((Dc1+Df1/2)^2+h1^2)^0.5*tan(omega1/2)
  Wf1=2*(Df1^2+h1^2)^0.5*tan(omega1/2)
  positions1 <- data.frame(
    x = c(0, 0, Df1-Dc1, Df1-Dc1),
    y = c(-Wc1/2, Wc1/2, -Wf1/2, Wf1/2)
  )

  Wc2=2*(Dc2^2+h2^2)^0.5*tan(omega2/2)
  Wm2=2*((Dc2+Df2/2)^2+h2^2)^0.5*tan(omega2/2)
  Wf2=2*(Df2^2+h2^2)^0.5*tan(omega2/2)
  positions2 <- data.frame(
    x = c(0, 0, Df2-Dc2, Df2-Dc2),
    y = c(-Wc2/2+forward_distance, Wc2/2+forward_distance,
          -Wf2/2+forward_distance, Wf2/2+forward_distance)
  )

  library(sp)
  p = Polygon(positions1[c(1,2,4,3),] )
  ps = Polygons(list(p),1)
  sps = SpatialPolygons(list(ps))
  p2 = Polygon(positions2[c(1,2,4,3),] )
  ps2 = Polygons(list(p2),1)
  sps2 = SpatialPolygons(list(ps2))
  #plot(rgeos::gIntersection(sps,sps2), add=TRUE)
  area=rgeos::gIntersection(sps,sps2)
  if(is.null(area)){
    overlap_df7$forward_overlap[i]=0
  }else{
    overlap_df7$forward_overlap[i]=area@polygons[[1]]@area
  }
}
overlap_df7$forward_overlap
###################################################################
overlap_df8=overlap_df %>%
  filter(Flight=="Flight8")

overlap_df8$forward_overlap=rep(NA,dim(overlap_df8)[1])

dim(overlap_df8)
for (i in 2:1532){

  altitude1=overlap_df8$altitude1[i]
  altitude2=overlap_df8$altitude2[i]
  forward_distance=overlap_df8$distance[i]
  angle_of_camera=25
  banking_angle1=overlap_df8$banking_angle1[i]
  banking_angle2=overlap_df8$banking_angle2[i]



  #Picture1
  h1=altitude1
  # angle of camera1
  theta1 <- Kulan::deg_to_rad(angle_of_camera)
  # horizontal field of view
  phi1 <- Kulan::deg_to_rad(Kulan::get_HFOV()+banking_angle1)
  # vertical field of view
  omega1 <- Kulan::deg_to_rad(Kulan::get_VFOV())
  Dc1= h1*tan(theta1-phi1/2)
  Df1= h1*tan(theta1+phi1/2)
  Dm1= h1*tan(theta1+phi1*0.5/2)
  Rc1=sqrt(h1^2+Dc1^2)
  Rm1=sqrt(h1^2+Dm1^2)
  Rf1=sqrt(h1^2+Df1^2)

  #Picture2
  h2=altitude2
  # angle of camera2
  theta2 <- Kulan::deg_to_rad(angle_of_camera)
  # horizontal field of view
  phi2 <- Kulan::deg_to_rad(Kulan::get_HFOV()+banking_angle2)
  # vertical field of view
  omega2 <- Kulan::deg_to_rad(Kulan::get_VFOV())
  Dc2= h2*tan(theta2-phi2/2)
  Df2= h2*tan(theta2+phi2/2)
  Dm2= h2*tan(theta2+phi2*0.5/2)
  Rc2=sqrt(h2^2+Dc2^2)
  Rm2=sqrt(h2^2+Dm2^2)
  Rf2=sqrt(h2^2+Df2^2)

  #Work out overlap between trapezoids
  Wc1=2*(Dc1^2+h1^2)^0.5*tan(omega1/2)
  Wm1=2*((Dc1+Df1/2)^2+h1^2)^0.5*tan(omega1/2)
  Wf1=2*(Df1^2+h1^2)^0.5*tan(omega1/2)
  positions1 <- data.frame(
    x = c(0, 0, Df1-Dc1, Df1-Dc1),
    y = c(-Wc1/2, Wc1/2, -Wf1/2, Wf1/2)
  )

  Wc2=2*(Dc2^2+h2^2)^0.5*tan(omega2/2)
  Wm2=2*((Dc2+Df2/2)^2+h2^2)^0.5*tan(omega2/2)
  Wf2=2*(Df2^2+h2^2)^0.5*tan(omega2/2)
  positions2 <- data.frame(
    x = c(0, 0, Df2-Dc2, Df2-Dc2),
    y = c(-Wc2/2+forward_distance, Wc2/2+forward_distance,
          -Wf2/2+forward_distance, Wf2/2+forward_distance)
  )

  library(sp)
  p = Polygon(positions1[c(1,2,4,3),] )
  ps = Polygons(list(p),1)
  sps = SpatialPolygons(list(ps))
  p2 = Polygon(positions2[c(1,2,4,3),] )
  ps2 = Polygons(list(p2),1)
  sps2 = SpatialPolygons(list(ps2))
  #plot(rgeos::gIntersection(sps,sps2), add=TRUE)
  area=rgeos::gIntersection(sps,sps2)
  if(is.null(area)){
    overlap_df8$forward_overlap[i]=0
  }else{
    overlap_df8$forward_overlap[i]=area@polygons[[1]]@area
  }
}
overlap_df8$forward_overlap

overlap_all=rbind(overlap_df1,overlap_df2,overlap_df3,overlap_df4,
      overlap_df5,overlap_df6,overlap_df7, overlap_df8)


```

The mean overlap per Flight is


```{r}
overlap_all %>%
    group_by(Flight) %>% 
  summarise(mnOver=mean(forward_overlap, na.rm=TRUE))

```

```{r}
distance_df %>% 
  left_join(overlap_all, by=c("photo_no"="photo_no"))%>%
  mutate(time=as.POSIXct(time,format="%H:%M:%S")) %>% 
  ggplot(aes(time,forward_overlap)) + 
  geom_point(colour="darkblue")+
  geom_line(colour="darkblue")+
  facet_wrap(~Flight.x, scales = "free")

```

## Side overlap

```{r}
all_dfs_reduced=all_dfs_reduced %>% 
  rowwise() %>% 
  mutate("side_overlap"=side_overlap(altitude = alt_above_ground, banking_angle = banking_angle))

all_dfs_reduced %>%
  mutate(time=as.POSIXct(time,format="%H:%M:%S")) %>% 
  ggplot(aes(time,side_overlap)) + 
  geom_point(colour="darkblue")+
  geom_line(colour="darkblue")+
  facet_wrap(~Flight, scales = "free")

```

## Ground surface resolution


```{r}
GSR_all_dfs=all_dfs_reduced %>% 
  rowwise() %>%mutate("GSD_near"=Kulan::GSD(altitude = alt_above_ground
                                 )[1])%>%  mutate("GSD_mid"=Kulan::GSD(altitude = alt_above_ground)[2]) %>% mutate("GSD_far"=Kulan::GSD(altitude = alt_above_ground)[3])
GSR_all_dfs %>% 
  group_by(Flight) %>% 
  summarise(cm_per_pixel_near=mean(unlist(GSD_near), na.rm=TRUE), sd_cm_per_pixel_near=sd(unlist(GSD_near), na.rm=TRUE),cm_per_pixel_far=mean(unlist(GSD_far), na.rm=TRUE), sd_cm_per_pixel_far=sd(unlist(GSD_far), na.rm=TRUE))

```

## Distance of each flight

```{r}
(dist_sum=distance_df %>% 
  group_by(Flight) %>% 
  summarise(Distance=sum(coord_dif, na.rm=TRUE)))
```


## Generate summary ouputs

### Flight summary table 

```{r}
output_summary_table=all_dfs_reduced %>% 
  group_by(Flight) %>% 
  summarise(Date=min(date),  Time_start=min(time), Time_end=max(time), Mean_Altitude=mean(alt_above_ground, na.rm=TRUE), SD_Altitude=sd(alt_above_ground, na.rm=TRUE), Mean_GPS_Speed= mean(gps_speed, na.rm=TRUE),SD_GPS_Speed= sd(gps_speed, na.rm=TRUE), Mean_Banking= mean(banking_angle, na.rm=TRUE),SD_Banking= sd(banking_angle, na.rm=TRUE), Mean_Strip_Width=mean(strip_width, na.rm=TRUE), SD_Strip_width=sd(strip_width, na.rm=TRUE), Mean_side_overlap=mean(side_overlap, na.rm=TRUE), SD_side_overlap=sd(side_overlap,na.rm=TRUE), Mean_photo_area=mean(photo_area, na.rm=TRUE), SD_photo_area=sd(photo_area, na.rm=TRUE))

over_sum=overlap_all %>% 
  group_by(Flight) %>% 
  summarise(Mean_Overlap=mean(forward_overlap, na.rm=TRUE), SD_Overlap=sd(forward_overlap, na.rm=TRUE))

no_photos=all_dfs_reduced %>% 
  group_by(Flight) %>% 
  tally()

output_summary_table=output_summary_table %>% inner_join(over_sum, by=c("Flight"="Flight"))

output_summary_table=output_summary_table %>% inner_join(GSR_all_dfs)

output_summary_table =output_summary_table %>% inner_join(no_photos)

output_summary_table=output_summary_table %>% 
  inner_join(dist_sum)

output_summary_table %>% 
  rename(.,"no_of_photos"="n")
# You can write the table to .csv using this code below
#write.csv(output_summary_table, "Summary_per_Flight.csv")
```

```{r}
kableExtra::kable(output_summary_table) %>% 
  kableExtra::kable_styling()
```


### Export to excel

```{r}

Export_2_excel=all_dfs_reduced %>% 
  mutate(strip_width_1_side=strip_width)

Export_2_excel$GSD=GSR_all_dfs$GSR


# You can write this table to excel by running this line (delete the "comment" '#' symbol)
#write.csv(Export_2_excel, "Flight_data.csv")


```

