---
title: "Flight summaries"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Flight summaries}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
options(qwraps2_markup = "markdown")
library(tidyverse)
library(readr)
library(qwraps2)
library(Kulan)
library(ggpubr)
library(geosphere)
```


## Call in files from a nested folder and clean them

```{r make a large dataset, echo=TRUE, message=FALSE, warning=FALSE}
library(here)
#here::here()
path=paste0(here::here(),"/", "data/tables")
#list.files(path)
all_dfs=Kulan::get_tables(path, ".csv")
all_dfs=all_dfs %>% 
  janitor::clean_names() %>% 
  rename(., Flight = class)

#clean up the time format if needed (some issues with xls files)
# all_dfs <- all_dfs %>%
#             mutate(time = update(time,
#                        year = year(date),
#                        month = month(date),
#                        day = day(date)),
#             hms = hms::as_hms(time))

#Make sure values are recognized as numeric
all_dfs=all_dfs %>%
  mutate(banking_angle=as.numeric(banking_angle)) %>%
  mutate(tangage=as.numeric(tangage)) %>%
  mutate(azimuth=as.numeric(azimuth)) %>%
  mutate(gps_course=as.numeric(gps_course)) %>%
  mutate(speed=as.numeric(speed)) %>%
  mutate(gps_speed=as.numeric(gps_speed))

#shows if values are correctly defined
str(all_dfs)


```

## Extract raster values from a DEM for the altitude above ground calculations

At this point you could add the altitude from the DEM [see the "Getting raster values form a Digital Elevation Model" vignette]. Here, for this example, we will use the column called Altitude above the ground (*because we can not include all the DEMs we would need inside the package*).

## Remove points where the drone is in take-off or landing

### First plot the data

```{r}
all_dfs %>% 
  mutate(time2=as.POSIXct(time,format="%H:%M:%S")) %>% 
  ggplot(aes(time2, alt_above_ground, colour=Flight))+ 
  geom_point()+
  labs(x="time",y= "Altitude above ground")+
  theme(legend.position = "None")+
  facet_wrap(~Flight)

```

From the distribution of the altitudes we can see that anything below 200 m is probably take-off or landing phase. 

```{r}
all_dfs %>% 
  ggplot(aes(alt_above_ground))+
  geom_histogram(fill="Red")
```

However, we might want to look more closely at Flight5 as it seems some of the points during the flight are below 200m.

```{r}
all_dfs %>% 
  filter(Flight=="Flight5") %>% 
  ggplot(aes(time, alt_above_ground, colour=Flight)) +
  labs(y= "Altitude above sea level")+
  theme(axis.text.x = element_blank())+
  geom_point()+
  geom_hline(yintercept = 200, colour="Red", lty=2) +
  geom_hline(yintercept = 190, colour="Green", lty=2) +
  theme(legend.position = "None")

```

So a couple of points in Flight5 during the actual flight were below our threshold of 200m. So let's be conservative and go for 190m instead. You can change this threshold by changing the value in the code below.

```{r}
dfs_reduced=all_dfs %>% 
  filter(alt_above_ground>190)# The threshold is controlled here - change it by changing the number from 190
```

Now all the points in consideration are above 190m. 

## Drone flight descriptors     

### Altitude above ground summary

```{r}
dfs_reduced %>% 
   mutate(time2=as.POSIXct(time,format="%H:%M:%S")) %>% 
  ggplot(aes(time2,alt_above_ground))+
  geom_point(colour="darkblue")+
  geom_line(colour="darkblue")+
  labs(x="time", y="Altitude above the ground")+
  facet_wrap(Flight~., scale="free")

```

##  Trapeze - drone footprint for specific altitude example     

```{r}

#####################################################################################################################
# Drone & camera setup:
# Camera: SONY DCS-RX1RM2
# Sensor: 35.9 x 24.0 mm
# VIEWING ANGLE LENS (CORRESPONDING 35 MM FORMAT) 63 degrees (35mm))
# Image width in pixel: 7952
# Image height in pixel: 5304
# Camera angles 25.7 and 25.0 degrees
# distance between two lenses is 2,9-3,0 cm - this distance is in the forward direction 
# as both cameras are directly in the middle of the drone
#####################################################################################################################

library(patchwork)
#short version of the below functions:
#Kulan::plot_trapezoid(altitude = 200, banking_angle = 0)

# calculat trapez based on drone specifications
# sensor and camera details
xsensor	= 35.9   #sensor width
ysensor	= 24     #sensor height
focallen	= 35     #focal length of lens
ygim     	= 0      #roll
xgim1    = 25     #banking angle = camera angle 1
Xgim2	= 25.7   #banking angle = camera angle 2
alt      	= 245    #fight height - change according to values seen under 4.3., I subsequently changed alt = alt, so it 
imW      = 7952   #sensor width
imH	= 5304   #sensor length
#####################################################################################################################
#######################  5.2.1. trapeze side view
#####################################################################################################################
deg2rad<-function(d) {
  rad = d * pi / 180
  return(rad)
}

rad2deg<-function(rad) {
  deg=rad*180/pi
  return(deg)
}

FOV.wide<-rad2deg(2*atan(xsensor/(2*focallen)))
FOV.high<-rad2deg(2*atan(ysensor/(2*focallen)))

theta <- deg2rad(xgim1)
# horizontal field of view
phi <- deg2rad(FOV.wide)
# vertical field of view
omega <- deg2rad(FOV.high)

Dc = alt*tan(theta-phi/2)
Df = alt*tan(theta+phi/2)
Dm = alt*tan(theta+phi*0.5/2)

Rc = sqrt(alt^2+Dc^2)
Rm = sqrt(alt^2+Dm^2)
Rf = sqrt(alt^2+Df^2)

dt.triangle  <- data.table(group = c(1,1,1), polygon.x = c(0,Dc,0), polygon.y = c(alt,0,0))
dt.triangle2 <- data.table(group = c(1,1,1), polygon.x = c(0,Df,0), polygon.y = c(alt,0,0))

#plotting side view
p <- ggplot()
p <- p + geom_polygon(
  data = dt.triangle
  ,aes(
    x=polygon.x
    ,y=polygon.y
    ,group=group
  )
)
p+geom_polygon(
  data = dt.triangle2
  ,aes(
    x=polygon.x
    ,y=polygon.y
    ,group=group
    , alpha=0.2
  ))+
  labs(x="Horizontal distance", y="Vertical distance")+
  theme(legend.position = "None")



```

### Adding the other camera

In our case we have two cameras with different angles and we can plot these to show the images horizontal footprints.
```{r}

theta2 <- deg2rad(Xgim2)
Dc2 = alt*tan(theta2-phi/2)
Df2 = alt*tan(theta2+phi/2)
Dm2 = alt*tan(theta2+phi*0.5/2)

dt.triangle  <- data.table(group = c(1,1,1), polygon.x = c(0,Dc,0), polygon.y = c(alt,0,0))
dt.triangle2 <- data.table(group = c(1,1,1), polygon.x = c(0,Df,0), polygon.y = c(alt,0,0))

dt.triangle3 <- data.table(group = c(2,2,2), polygon.x3 = c(0,-Dc2,0), polygon.y3 = c(alt,0,0))
dt.triangle3 <- data.table(group = c(2,2,2), polygon.x3 = c(0,-Df2,0), polygon.y3 = c(alt,0,0))

p <- ggplot()
p <- p + geom_polygon(
  data = dt.triangle
  ,aes(
    x=polygon.x
    ,y=polygon.y
    ,group=group
  )
)
p<-p+geom_polygon(
  data = dt.triangle2
  ,aes(
    x=polygon.x
    ,y=polygon.y
    ,group=group
    , alpha=0.2
  ))
p+geom_polygon(
  data = dt.triangle3
  ,aes(
    x=polygon.x3
    ,y=polygon.y3
    ,group=group
    , alpha=0.2
  ))+
  labs(x="Horizontal distance", y="Vertical distance")+
  theme(legend.position = "None")

```

##  Trapeze top view
```{r}
#Top view
Wc = 2*(Dc^2+alt^2)^0.5*tan(omega/2)
Wm = 2*((Dc+Df/2)^2+alt^2)^0.5*tan(omega/2)
Wf = 2*(Df^2+alt^2)^0.5*tan(omega/2)

positions <- data.frame(
  x = c(0, 0, Df-Dc, Df-Dc),
  y = c(-Wc/2, Wc/2, -Wf/2, Wf/2)
)
ggplot(positions[c(1,2,4,3),], aes(x = x, y = y)) +
  geom_polygon(aes(fill = "red"))+
  labs(x="", y="")+
  theme_classic()+
  theme(legend.position = "None")

```



## Strip-width summary

```{r, results='asis', echo=TRUE, message=FALSE, warning=FALSE}
 dfs_reduced=dfs_reduced%>% 
    group_by(Flight) %>%
  filter(!str_detect(photo_no, "IMG")) %>% # remove empty photos
  rowwise() %>% 
  mutate("strip_width"=get_strip_width(alt=alt_above_ground,banking_angle = banking_angle)) %>% 
  drop_na(strip_width)
 our_summary1 <-
  list("strip width (m)" =
         list("min"       = ~ round(min(strip_width)),
              "max"       = ~ round(max(strip_width)),
              "mean (sd)" = ~qwraps2::mean_sd(strip_width)))


tab_1<-qwraps2::summary_table(dplyr::group_by(dfs_reduced, Flight),our_summary1)
tab_1

```

## Speed summary

Using the gps_speed we can plot the speed of the drone during each flight.

```{r}

dfs_reduced%>% 
  mutate(rowid=row_number()) %>% 
  mutate(time2=as.POSIXct(time,format="%H:%M:%S")) %>% 
  #ggplot(aes(time2,gps_speed))+# replace the next line with this to remove the alt_above_ground colour
  ggplot(aes(time2,gps_speed,colour=alt_above_ground))+
  geom_point()+
  geom_line()+
  labs(x="time", y="gps speed")+
  #geom_point(colour="darkblue")+# add these lines too and remove the two above
  #geom_line(colour="darkblue")+#
  facet_wrap(~Flight, scales="free")
```

## Distance between points summary

There are some very large distances moved at the start or the end of a Flight and these need to be filtered out to allow us to plot the distance more clearly. Anything above 250m is therefore removed in the plotting code below.The points are coloured by the gps_speed. 

```{r}
distance_df=dfs_reduced%>% 
  group_by(Flight) %>% 
  mutate(new_lat=lag(lat_dec)) %>%
  mutate(new_lon=lag(lon_dec)) %>%
  rowwise() %>%
  mutate(coord_dif=distm(c(lon_dec, lat_dec), c(new_lon, new_lat), fun = distHaversine))

distance_df %>% 
  group_by(Flight) %>% 
   mutate(time2=as.POSIXct(time,format="%H:%M:%S")) %>% 
  filter(coord_dif<250) %>% 
  ggplot(aes(time2,coord_dif,colour=coord_dif))+
  geom_point()+
  geom_line()+
  scale_colour_gradientn(colours = terrain.colors(10))+
  labs(x="time",y="distance (m) between points")+
  facet_wrap(~Flight, scales="free")
```

## Banking Angle


```{r}
dfs_reduced%>% 
  mutate(rowid=row_number()) %>% 
  mutate(time2=as.POSIXct(time,format="%H:%M:%S")) %>% 
  ggplot(aes(time2,banking_angle))+
  geom_point(colour="darkblue")+
  geom_line(colour="darkblue")+
  labs(x="time", y="Banking angle")+
  facet_wrap(~Flight, scales="free")
```

## Photograph area on the right side

```{r}
dfs_reduced=dfs_reduced %>% 
  rowwise() %>% 
  mutate("photo_area_R"=Kulan::get_photo_area(altitude = alt_above_ground,banking_angle = banking_angle))


dfs_reduced %>% 
  dplyr::select(photo_area_R) %>% 
  ggplot(aes(photo_area_R))+
  labs(x="photograph area m2")+
  geom_histogram(fill="red")+
  theme_classic()
```

## Photograph area on the left side

We need to change the camera angle from the default (which is set for the right side camera) in order to calculate the photo area on the left.

```{r}
dfs_reduced=dfs_reduced %>% 
  rowwise() %>% 
  mutate("photo_area_L"=Kulan::get_photo_area(altitude = alt_above_ground, angle_of_camera = 25.7 ,banking_angle = banking_angle))


dfs_reduced %>% 
  dplyr::select(photo_area_L) %>% 
  ggplot(aes(photo_area_L))+
  labs(x="photograph area m2")+
  geom_histogram(fill="red")+
  theme_classic()
```

## Overlap

The forward overlap is the percentage overlap that two consecutive images have. To calculate this value we could not use a single function so have developed a script to follow the process. This is hidden here in the rendered Markdown but contained in the script.

```{r, echo=TRUE,message=FALSE,results="hide"}
overlap_df=distance_df %>% 
  select(photo_no, alt_above_ground, coord_dif, banking_angle, Flight)

overlap_df$altitude1=overlap_df$alt_above_ground
overlap_df$altitude2=lead(overlap_df$altitude1)
overlap_df$distance=overlap_df$coord_dif
overlap_df$banking_angle1=overlap_df$banking_angle
overlap_df$banking_angle2=lead(overlap_df$banking_angle1)


overlap_df1=overlap_df %>%
  filter(Flight=="Flight1")

overlap_df1$forward_overlap=rep(NA,dim(overlap_df1)[1])


for (i in 2:dim(overlap_df1)[1]){

  altitude1=overlap_df1$altitude1[i]
  altitude2=overlap_df1$altitude2[i]
  forward_distance=overlap_df1$distance[i]
  angle_of_camera=25
  banking_angle1=overlap_df1$banking_angle1[i]
  banking_angle2=overlap_df1$banking_angle2[i]



  #Picture1
  h1=altitude1
  # angle of camera1
  theta1 <- Kulan::deg_to_rad(angle_of_camera)
  # horizontal field of view
  phi1 <- Kulan::deg_to_rad(Kulan::get_HFOV()+banking_angle1)
  # vertical field of view
  omega1 <- Kulan::deg_to_rad(Kulan::get_VFOV())
  Dc1= h1*tan(theta1-phi1/2)
  Df1= h1*tan(theta1+phi1/2)
  Dm1= h1*tan(theta1+phi1*0.5/2)
  Rc1=sqrt(h1^2+Dc1^2)
  Rm1=sqrt(h1^2+Dm1^2)
  Rf1=sqrt(h1^2+Df1^2)

  #Picture2
  h2=altitude2
  # angle of camera2
  theta2 <- Kulan::deg_to_rad(angle_of_camera)
  # horizontal field of view
  phi2 <- Kulan::deg_to_rad(Kulan::get_HFOV()+banking_angle2)
  # vertical field of view
  omega2 <- Kulan::deg_to_rad(Kulan::get_VFOV())
  Dc2= h2*tan(theta2-phi2/2)
  Df2= h2*tan(theta2+phi2/2)
  Dm2= h2*tan(theta2+phi2*0.5/2)
  Rc2=sqrt(h2^2+Dc2^2)
  Rm2=sqrt(h2^2+Dm2^2)
  Rf2=sqrt(h2^2+Df2^2)

  #Work out overlap between trapezoids
  Wc1=2*(Dc1^2+h1^2)^0.5*tan(omega1/2)
  Wm1=2*((Dc1+Df1/2)^2+h1^2)^0.5*tan(omega1/2)
  Wf1=2*(Df1^2+h1^2)^0.5*tan(omega1/2)
  positions1 <- data.frame(
    x = c(0, 0, Df1-Dc1, Df1-Dc1),
    y = c(-Wc1/2, Wc1/2, -Wf1/2, Wf1/2)
  )

  Wc2=2*(Dc2^2+h2^2)^0.5*tan(omega2/2)
  Wm2=2*((Dc2+Df2/2)^2+h2^2)^0.5*tan(omega2/2)
  Wf2=2*(Df2^2+h2^2)^0.5*tan(omega2/2)
  positions2 <- data.frame(
    x = c(0, 0, Df2-Dc2, Df2-Dc2),
    y = c(-Wc2/2+forward_distance, Wc2/2+forward_distance,
          -Wf2/2+forward_distance, Wf2/2+forward_distance)
  )

  library(sp)
  p = Polygon(positions1[c(1,2,4,3),] )
  ps = Polygons(list(p),1)
  sps = SpatialPolygons(list(ps))
  p2 = Polygon(positions2[c(1,2,4,3),] )
  ps2 = Polygons(list(p2),1)
  sps2 = SpatialPolygons(list(ps2))
  #plot(rgeos::gIntersection(sps,sps2), add=TRUE)
  area=rgeos::gIntersection(sps,sps2)
  if(is.null(area)){
    overlap_df1$forward_overlap[i]=0
  }else{
  overlap_df1$forward_overlap[i]=area@polygons[[1]]@area
  }
}
overlap_df1$forward_overlap

###############################################################

overlap_df2=overlap_df %>%
  filter(Flight=="Flight2")

overlap_df2$forward_overlap=rep(NA,dim(overlap_df2)[1])


for (i in 2:dim(overlap_df2)[1]){

  altitude1=overlap_df2$altitude1[i]
  altitude2=overlap_df2$altitude2[i]
  forward_distance=overlap_df2$distance[i]
  angle_of_camera=25
  banking_angle1=overlap_df2$banking_angle1[i]
  banking_angle2=overlap_df2$banking_angle2[i]



  #Picture1
  h1=altitude1
  # angle of camera1
  theta1 <- Kulan::deg_to_rad(angle_of_camera)
  # horizontal field of view
  phi1 <- Kulan::deg_to_rad(Kulan::get_HFOV()+banking_angle1)
  # vertical field of view
  omega1 <- Kulan::deg_to_rad(Kulan::get_VFOV())
  Dc1= h1*tan(theta1-phi1/2)
  Df1= h1*tan(theta1+phi1/2)
  Dm1= h1*tan(theta1+phi1*0.5/2)
  Rc1=sqrt(h1^2+Dc1^2)
  Rm1=sqrt(h1^2+Dm1^2)
  Rf1=sqrt(h1^2+Df1^2)

  #Picture2
  h2=altitude2
  # angle of camera2
  theta2 <- Kulan::deg_to_rad(angle_of_camera)
  # horizontal field of view
  phi2 <- Kulan::deg_to_rad(Kulan::get_HFOV()+banking_angle2)
  # vertical field of view
  omega2 <- Kulan::deg_to_rad(Kulan::get_VFOV())
  Dc2= h2*tan(theta2-phi2/2)
  Df2= h2*tan(theta2+phi2/2)
  Dm2= h2*tan(theta2+phi2*0.5/2)
  Rc2=sqrt(h2^2+Dc2^2)
  Rm2=sqrt(h2^2+Dm2^2)
  Rf2=sqrt(h2^2+Df2^2)

  #Work out overlap between trapezoids
  Wc1=2*(Dc1^2+h1^2)^0.5*tan(omega1/2)
  Wm1=2*((Dc1+Df1/2)^2+h1^2)^0.5*tan(omega1/2)
  Wf1=2*(Df1^2+h1^2)^0.5*tan(omega1/2)
  positions1 <- data.frame(
    x = c(0, 0, Df1-Dc1, Df1-Dc1),
    y = c(-Wc1/2, Wc1/2, -Wf1/2, Wf1/2)
  )

  Wc2=2*(Dc2^2+h2^2)^0.5*tan(omega2/2)
  Wm2=2*((Dc2+Df2/2)^2+h2^2)^0.5*tan(omega2/2)
  Wf2=2*(Df2^2+h2^2)^0.5*tan(omega2/2)
  positions2 <- data.frame(
    x = c(0, 0, Df2-Dc2, Df2-Dc2),
    y = c(-Wc2/2+forward_distance, Wc2/2+forward_distance,
          -Wf2/2+forward_distance, Wf2/2+forward_distance)
  )

  library(sp)
  p = Polygon(positions1[c(1,2,4,3),] )
  ps = Polygons(list(p),1)
  sps = SpatialPolygons(list(ps))
  p2 = Polygon(positions2[c(1,2,4,3),] )
  ps2 = Polygons(list(p2),1)
  sps2 = SpatialPolygons(list(ps2))
  #plot(rgeos::gIntersection(sps,sps2), add=TRUE)
  area=rgeos::gIntersection(sps,sps2)
  if(is.null(area)){
    overlap_df2$forward_overlap[i]=0
  }else{
    overlap_df2$forward_overlap[i]=area@polygons[[1]]@area
  }
}
overlap_df2$forward_overlap

########################################################
overlap_df3=overlap_df %>%
  filter(Flight=="Flight3")

overlap_df3$forward_overlap=rep(NA,dim(overlap_df3)[1])


for (i in 2:dim(overlap_df3)[1]){

  altitude1=overlap_df3$altitude1[i]
  altitude2=overlap_df3$altitude2[i]
  forward_distance=overlap_df3$distance[i]
  angle_of_camera=25
  banking_angle1=overlap_df3$banking_angle1[i]
  banking_angle2=overlap_df3$banking_angle2[i]



  #Picture1
  h1=altitude1
  # angle of camera1
  theta1 <- Kulan::deg_to_rad(angle_of_camera)
  # horizontal field of view
  phi1 <- Kulan::deg_to_rad(Kulan::get_HFOV()+banking_angle1)
  # vertical field of view
  omega1 <- Kulan::deg_to_rad(Kulan::get_VFOV())
  Dc1= h1*tan(theta1-phi1/2)
  Df1= h1*tan(theta1+phi1/2)
  Dm1= h1*tan(theta1+phi1*0.5/2)
  Rc1=sqrt(h1^2+Dc1^2)
  Rm1=sqrt(h1^2+Dm1^2)
  Rf1=sqrt(h1^2+Df1^2)

  #Picture2
  h2=altitude2
  # angle of camera2
  theta2 <- Kulan::deg_to_rad(angle_of_camera)
  # horizontal field of view
  phi2 <- Kulan::deg_to_rad(Kulan::get_HFOV()+banking_angle2)
  # vertical field of view
  omega2 <- Kulan::deg_to_rad(Kulan::get_VFOV())
  Dc2= h2*tan(theta2-phi2/2)
  Df2= h2*tan(theta2+phi2/2)
  Dm2= h2*tan(theta2+phi2*0.5/2)
  Rc2=sqrt(h2^2+Dc2^2)
  Rm2=sqrt(h2^2+Dm2^2)
  Rf2=sqrt(h2^2+Df2^2)

  #Work out overlap between trapezoids
  Wc1=2*(Dc1^2+h1^2)^0.5*tan(omega1/2)
  Wm1=2*((Dc1+Df1/2)^2+h1^2)^0.5*tan(omega1/2)
  Wf1=2*(Df1^2+h1^2)^0.5*tan(omega1/2)
  positions1 <- data.frame(
    x = c(0, 0, Df1-Dc1, Df1-Dc1),
    y = c(-Wc1/2, Wc1/2, -Wf1/2, Wf1/2)
  )

  Wc2=2*(Dc2^2+h2^2)^0.5*tan(omega2/2)
  Wm2=2*((Dc2+Df2/2)^2+h2^2)^0.5*tan(omega2/2)
  Wf2=2*(Df2^2+h2^2)^0.5*tan(omega2/2)
  positions2 <- data.frame(
    x = c(0, 0, Df2-Dc2, Df2-Dc2),
    y = c(-Wc2/2+forward_distance, Wc2/2+forward_distance,
          -Wf2/2+forward_distance, Wf2/2+forward_distance)
  )

  library(sp)
  p = Polygon(positions1[c(1,2,4,3),] )
  ps = Polygons(list(p),1)
  sps = SpatialPolygons(list(ps))
  p2 = Polygon(positions2[c(1,2,4,3),] )
  ps2 = Polygons(list(p2),1)
  sps2 = SpatialPolygons(list(ps2))
  #plot(rgeos::gIntersection(sps,sps2), add=TRUE)
  area=rgeos::gIntersection(sps,sps2)
  if(is.null(area)){
    overlap_df3$forward_overlap[i]=0
  }else{
    overlap_df3$forward_overlap[i]=area@polygons[[1]]@area
  }
}
overlap_df3$forward_overlap

###########################################################

overlap_df4=overlap_df %>%
  filter(Flight=="Flight4")

overlap_df4$forward_overlap=rep(NA,dim(overlap_df4)[1])

for (i in 2:dim(overlap_df4)[1]){

  altitude1=overlap_df4$altitude1[i]
  altitude2=overlap_df4$altitude2[i]
  forward_distance=overlap_df4$distance[i]
  angle_of_camera=25
  banking_angle1=overlap_df4$banking_angle1[i]
  banking_angle2=overlap_df4$banking_angle2[i]



  #Picture1
  h1=altitude1
  # angle of camera1
  theta1 <- Kulan::deg_to_rad(angle_of_camera)
  # horizontal field of view
  phi1 <- Kulan::deg_to_rad(Kulan::get_HFOV()+banking_angle1)
  # vertical field of view
  omega1 <- Kulan::deg_to_rad(Kulan::get_VFOV())
  Dc1= h1*tan(theta1-phi1/2)
  Df1= h1*tan(theta1+phi1/2)
  Dm1= h1*tan(theta1+phi1*0.5/2)
  Rc1=sqrt(h1^2+Dc1^2)
  Rm1=sqrt(h1^2+Dm1^2)
  Rf1=sqrt(h1^2+Df1^2)

  #Picture2
  h2=altitude2
  # angle of camera2
  theta2 <- Kulan::deg_to_rad(angle_of_camera)
  # horizontal field of view
  phi2 <- Kulan::deg_to_rad(Kulan::get_HFOV()+banking_angle2)
  # vertical field of view
  omega2 <- Kulan::deg_to_rad(Kulan::get_VFOV())
  Dc2= h2*tan(theta2-phi2/2)
  Df2= h2*tan(theta2+phi2/2)
  Dm2= h2*tan(theta2+phi2*0.5/2)
  Rc2=sqrt(h2^2+Dc2^2)
  Rm2=sqrt(h2^2+Dm2^2)
  Rf2=sqrt(h2^2+Df2^2)

  #Work out overlap between trapezoids
  Wc1=2*(Dc1^2+h1^2)^0.5*tan(omega1/2)
  Wm1=2*((Dc1+Df1/2)^2+h1^2)^0.5*tan(omega1/2)
  Wf1=2*(Df1^2+h1^2)^0.5*tan(omega1/2)
  positions1 <- data.frame(
    x = c(0, 0, Df1-Dc1, Df1-Dc1),
    y = c(-Wc1/2, Wc1/2, -Wf1/2, Wf1/2)
  )

  Wc2=2*(Dc2^2+h2^2)^0.5*tan(omega2/2)
  Wm2=2*((Dc2+Df2/2)^2+h2^2)^0.5*tan(omega2/2)
  Wf2=2*(Df2^2+h2^2)^0.5*tan(omega2/2)
  positions2 <- data.frame(
    x = c(0, 0, Df2-Dc2, Df2-Dc2),
    y = c(-Wc2/2+forward_distance, Wc2/2+forward_distance,
          -Wf2/2+forward_distance, Wf2/2+forward_distance)
  )

  library(sp)
  p = Polygon(positions1[c(1,2,4,3),] )
  ps = Polygons(list(p),1)
  sps = SpatialPolygons(list(ps))
  p2 = Polygon(positions2[c(1,2,4,3),] )
  ps2 = Polygons(list(p2),1)
  sps2 = SpatialPolygons(list(ps2))
  #plot(rgeos::gIntersection(sps,sps2), add=TRUE)
  area=rgeos::gIntersection(sps,sps2)
  if(is.null(area)){
    overlap_df4$forward_overlap[i]=0
  }else{
    overlap_df4$forward_overlap[i]=area@polygons[[1]]@area
  }
}
overlap_df4$forward_overlap

###############################################################
overlap_df5=overlap_df %>%
  filter(Flight=="Flight5")

overlap_df5$forward_overlap=rep(NA,dim(overlap_df5)[1])


for (i in 2:dim(overlap_df5)[1]){

  altitude1=overlap_df5$altitude1[i]
  altitude2=overlap_df5$altitude2[i]
  forward_distance=overlap_df5$distance[i]
  angle_of_camera=25
  banking_angle1=overlap_df5$banking_angle1[i]
  banking_angle2=overlap_df5$banking_angle2[i]



  #Picture1
  h1=altitude1
  # angle of camera1
  theta1 <- Kulan::deg_to_rad(angle_of_camera)
  # horizontal field of view
  phi1 <- Kulan::deg_to_rad(Kulan::get_HFOV()+banking_angle1)
  # vertical field of view
  omega1 <- Kulan::deg_to_rad(Kulan::get_VFOV())
  Dc1= h1*tan(theta1-phi1/2)
  Df1= h1*tan(theta1+phi1/2)
  Dm1= h1*tan(theta1+phi1*0.5/2)
  Rc1=sqrt(h1^2+Dc1^2)
  Rm1=sqrt(h1^2+Dm1^2)
  Rf1=sqrt(h1^2+Df1^2)

  #Picture2
  h2=altitude2
  # angle of camera2
  theta2 <- Kulan::deg_to_rad(angle_of_camera)
  # horizontal field of view
  phi2 <- Kulan::deg_to_rad(Kulan::get_HFOV()+banking_angle2)
  # vertical field of view
  omega2 <- Kulan::deg_to_rad(Kulan::get_VFOV())
  Dc2= h2*tan(theta2-phi2/2)
  Df2= h2*tan(theta2+phi2/2)
  Dm2= h2*tan(theta2+phi2*0.5/2)
  Rc2=sqrt(h2^2+Dc2^2)
  Rm2=sqrt(h2^2+Dm2^2)
  Rf2=sqrt(h2^2+Df2^2)

  #Work out overlap between trapezoids
  Wc1=2*(Dc1^2+h1^2)^0.5*tan(omega1/2)
  Wm1=2*((Dc1+Df1/2)^2+h1^2)^0.5*tan(omega1/2)
  Wf1=2*(Df1^2+h1^2)^0.5*tan(omega1/2)
  positions1 <- data.frame(
    x = c(0, 0, Df1-Dc1, Df1-Dc1),
    y = c(-Wc1/2, Wc1/2, -Wf1/2, Wf1/2)
  )

  Wc2=2*(Dc2^2+h2^2)^0.5*tan(omega2/2)
  Wm2=2*((Dc2+Df2/2)^2+h2^2)^0.5*tan(omega2/2)
  Wf2=2*(Df2^2+h2^2)^0.5*tan(omega2/2)
  positions2 <- data.frame(
    x = c(0, 0, Df2-Dc2, Df2-Dc2),
    y = c(-Wc2/2+forward_distance, Wc2/2+forward_distance,
          -Wf2/2+forward_distance, Wf2/2+forward_distance)
  )

  library(sp)
  p = Polygon(positions1[c(1,2,4,3),] )
  ps = Polygons(list(p),1)
  sps = SpatialPolygons(list(ps))
  p2 = Polygon(positions2[c(1,2,4,3),] )
  ps2 = Polygons(list(p2),1)
  sps2 = SpatialPolygons(list(ps2))
  #plot(rgeos::gIntersection(sps,sps2), add=TRUE)
  area=rgeos::gIntersection(sps,sps2)
  if(is.null(area)){
    overlap_df5$forward_overlap[i]=0
  }else{
    overlap_df5$forward_overlap[i]=area@polygons[[1]]@area
  }
}
overlap_df5$forward_overlap

################################################################
overlap_df6=overlap_df %>%
  filter(Flight=="Flight6")

overlap_df6$forward_overlap=rep(NA,dim(overlap_df6)[1])


for (i in 2:dim(overlap_df6)[1]){

  altitude1=overlap_df6$altitude1[i]
  altitude2=overlap_df6$altitude2[i]
  forward_distance=overlap_df6$distance[i]
  angle_of_camera=25
  banking_angle1=overlap_df6$banking_angle1[i]
  banking_angle2=overlap_df6$banking_angle2[i]



  #Picture1
  h1=altitude1
  # angle of camera1
  theta1 <- Kulan::deg_to_rad(angle_of_camera)
  # horizontal field of view
  phi1 <- Kulan::deg_to_rad(Kulan::get_HFOV()+banking_angle1)
  # vertical field of view
  omega1 <- Kulan::deg_to_rad(Kulan::get_VFOV())
  Dc1= h1*tan(theta1-phi1/2)
  Df1= h1*tan(theta1+phi1/2)
  Dm1= h1*tan(theta1+phi1*0.5/2)
  Rc1=sqrt(h1^2+Dc1^2)
  Rm1=sqrt(h1^2+Dm1^2)
  Rf1=sqrt(h1^2+Df1^2)

  #Picture2
  h2=altitude2
  # angle of camera2
  theta2 <- Kulan::deg_to_rad(angle_of_camera)
  # horizontal field of view
  phi2 <- Kulan::deg_to_rad(Kulan::get_HFOV()+banking_angle2)
  # vertical field of view
  omega2 <- Kulan::deg_to_rad(Kulan::get_VFOV())
  Dc2= h2*tan(theta2-phi2/2)
  Df2= h2*tan(theta2+phi2/2)
  Dm2= h2*tan(theta2+phi2*0.5/2)
  Rc2=sqrt(h2^2+Dc2^2)
  Rm2=sqrt(h2^2+Dm2^2)
  Rf2=sqrt(h2^2+Df2^2)

  #Work out overlap between trapezoids
  Wc1=2*(Dc1^2+h1^2)^0.5*tan(omega1/2)
  Wm1=2*((Dc1+Df1/2)^2+h1^2)^0.5*tan(omega1/2)
  Wf1=2*(Df1^2+h1^2)^0.5*tan(omega1/2)
  positions1 <- data.frame(
    x = c(0, 0, Df1-Dc1, Df1-Dc1),
    y = c(-Wc1/2, Wc1/2, -Wf1/2, Wf1/2)
  )

  Wc2=2*(Dc2^2+h2^2)^0.5*tan(omega2/2)
  Wm2=2*((Dc2+Df2/2)^2+h2^2)^0.5*tan(omega2/2)
  Wf2=2*(Df2^2+h2^2)^0.5*tan(omega2/2)
  positions2 <- data.frame(
    x = c(0, 0, Df2-Dc2, Df2-Dc2),
    y = c(-Wc2/2+forward_distance, Wc2/2+forward_distance,
          -Wf2/2+forward_distance, Wf2/2+forward_distance)
  )

  library(sp)
  p = Polygon(positions1[c(1,2,4,3),] )
  ps = Polygons(list(p),1)
  sps = SpatialPolygons(list(ps))
  p2 = Polygon(positions2[c(1,2,4,3),] )
  ps2 = Polygons(list(p2),1)
  sps2 = SpatialPolygons(list(ps2))
  #plot(rgeos::gIntersection(sps,sps2), add=TRUE)
  area=rgeos::gIntersection(sps,sps2)
  if(is.null(area)){
    overlap_df6$forward_overlap[i]=0
  }else{
    overlap_df6$forward_overlap[i]=area@polygons[[1]]@area
  }
}
overlap_df6$forward_overlap
###############################################################
overlap_df7=overlap_df %>%
  filter(Flight=="Flight7")

overlap_df7$forward_overlap=rep(NA,dim(overlap_df7)[1])


for (i in 2:dim(overlap_df7)[1]){

  altitude1=overlap_df7$altitude1[i]
  altitude2=overlap_df7$altitude2[i]
  forward_distance=overlap_df7$distance[i]
  angle_of_camera=25
  banking_angle1=overlap_df7$banking_angle1[i]
  banking_angle2=overlap_df7$banking_angle2[i]



  #Picture1
  h1=altitude1
  # angle of camera1
  theta1 <- Kulan::deg_to_rad(angle_of_camera)
  # horizontal field of view
  phi1 <- Kulan::deg_to_rad(Kulan::get_HFOV()+banking_angle1)
  # vertical field of view
  omega1 <- Kulan::deg_to_rad(Kulan::get_VFOV())
  Dc1= h1*tan(theta1-phi1/2)
  Df1= h1*tan(theta1+phi1/2)
  Dm1= h1*tan(theta1+phi1*0.5/2)
  Rc1=sqrt(h1^2+Dc1^2)
  Rm1=sqrt(h1^2+Dm1^2)
  Rf1=sqrt(h1^2+Df1^2)

  #Picture2
  h2=altitude2
  # angle of camera2
  theta2 <- Kulan::deg_to_rad(angle_of_camera)
  # horizontal field of view
  phi2 <- Kulan::deg_to_rad(Kulan::get_HFOV()+banking_angle2)
  # vertical field of view
  omega2 <- Kulan::deg_to_rad(Kulan::get_VFOV())
  Dc2= h2*tan(theta2-phi2/2)
  Df2= h2*tan(theta2+phi2/2)
  Dm2= h2*tan(theta2+phi2*0.5/2)
  Rc2=sqrt(h2^2+Dc2^2)
  Rm2=sqrt(h2^2+Dm2^2)
  Rf2=sqrt(h2^2+Df2^2)

  #Work out overlap between trapezoids
  Wc1=2*(Dc1^2+h1^2)^0.5*tan(omega1/2)
  Wm1=2*((Dc1+Df1/2)^2+h1^2)^0.5*tan(omega1/2)
  Wf1=2*(Df1^2+h1^2)^0.5*tan(omega1/2)
  positions1 <- data.frame(
    x = c(0, 0, Df1-Dc1, Df1-Dc1),
    y = c(-Wc1/2, Wc1/2, -Wf1/2, Wf1/2)
  )

  Wc2=2*(Dc2^2+h2^2)^0.5*tan(omega2/2)
  Wm2=2*((Dc2+Df2/2)^2+h2^2)^0.5*tan(omega2/2)
  Wf2=2*(Df2^2+h2^2)^0.5*tan(omega2/2)
  positions2 <- data.frame(
    x = c(0, 0, Df2-Dc2, Df2-Dc2),
    y = c(-Wc2/2+forward_distance, Wc2/2+forward_distance,
          -Wf2/2+forward_distance, Wf2/2+forward_distance)
  )

  library(sp)
  p = Polygon(positions1[c(1,2,4,3),] )
  ps = Polygons(list(p),1)
  sps = SpatialPolygons(list(ps))
  p2 = Polygon(positions2[c(1,2,4,3),] )
  ps2 = Polygons(list(p2),1)
  sps2 = SpatialPolygons(list(ps2))
  #plot(rgeos::gIntersection(sps,sps2), add=TRUE)
  area=rgeos::gIntersection(sps,sps2)
  if(is.null(area)){
    overlap_df7$forward_overlap[i]=0
  }else{
    overlap_df7$forward_overlap[i]=area@polygons[[1]]@area
  }
}
overlap_df7$forward_overlap
###################################################################
overlap_df8=overlap_df %>%
  filter(Flight=="Flight8")

overlap_df8$forward_overlap=rep(NA,dim(overlap_df8)[1])

dim(overlap_df8)
for (i in 2:1532){

  altitude1=overlap_df8$altitude1[i]
  altitude2=overlap_df8$altitude2[i]
  forward_distance=overlap_df8$distance[i]
  angle_of_camera=25
  banking_angle1=overlap_df8$banking_angle1[i]
  banking_angle2=overlap_df8$banking_angle2[i]



  #Picture1
  h1=altitude1
  # angle of camera1
  theta1 <- Kulan::deg_to_rad(angle_of_camera)
  # horizontal field of view
  phi1 <- Kulan::deg_to_rad(Kulan::get_HFOV()+banking_angle1)
  # vertical field of view
  omega1 <- Kulan::deg_to_rad(Kulan::get_VFOV())
  Dc1= h1*tan(theta1-phi1/2)
  Df1= h1*tan(theta1+phi1/2)
  Dm1= h1*tan(theta1+phi1*0.5/2)
  Rc1=sqrt(h1^2+Dc1^2)
  Rm1=sqrt(h1^2+Dm1^2)
  Rf1=sqrt(h1^2+Df1^2)

  #Picture2
  h2=altitude2
  # angle of camera2
  theta2 <- Kulan::deg_to_rad(angle_of_camera)
  # horizontal field of view
  phi2 <- Kulan::deg_to_rad(Kulan::get_HFOV()+banking_angle2)
  # vertical field of view
  omega2 <- Kulan::deg_to_rad(Kulan::get_VFOV())
  Dc2= h2*tan(theta2-phi2/2)
  Df2= h2*tan(theta2+phi2/2)
  Dm2= h2*tan(theta2+phi2*0.5/2)
  Rc2=sqrt(h2^2+Dc2^2)
  Rm2=sqrt(h2^2+Dm2^2)
  Rf2=sqrt(h2^2+Df2^2)

  #Work out overlap between trapezoids
  Wc1=2*(Dc1^2+h1^2)^0.5*tan(omega1/2)
  Wm1=2*((Dc1+Df1/2)^2+h1^2)^0.5*tan(omega1/2)
  Wf1=2*(Df1^2+h1^2)^0.5*tan(omega1/2)
  positions1 <- data.frame(
    x = c(0, 0, Df1-Dc1, Df1-Dc1),
    y = c(-Wc1/2, Wc1/2, -Wf1/2, Wf1/2)
  )

  Wc2=2*(Dc2^2+h2^2)^0.5*tan(omega2/2)
  Wm2=2*((Dc2+Df2/2)^2+h2^2)^0.5*tan(omega2/2)
  Wf2=2*(Df2^2+h2^2)^0.5*tan(omega2/2)
  positions2 <- data.frame(
    x = c(0, 0, Df2-Dc2, Df2-Dc2),
    y = c(-Wc2/2+forward_distance, Wc2/2+forward_distance,
          -Wf2/2+forward_distance, Wf2/2+forward_distance)
  )

  library(sp)
  p = Polygon(positions1[c(1,2,4,3),] )
  ps = Polygons(list(p),1)
  sps = SpatialPolygons(list(ps))
  p2 = Polygon(positions2[c(1,2,4,3),] )
  ps2 = Polygons(list(p2),1)
  sps2 = SpatialPolygons(list(ps2))
  #plot(rgeos::gIntersection(sps,sps2), add=TRUE)
  area=rgeos::gIntersection(sps,sps2)
  if(is.null(area)){
    overlap_df8$forward_overlap[i]=0
  }else{
    overlap_df8$forward_overlap[i]=area@polygons[[1]]@area
  }
}
overlap_df8$forward_overlap

overlap_all=rbind(overlap_df1,overlap_df2,overlap_df3,overlap_df4,
      overlap_df5,overlap_df6,overlap_df7, overlap_df8)


```

The mean overlap per Flight is in m2.


```{r}
overlap_all %>%
    group_by(Flight) %>% 
  summarise(mnOver=mean(forward_overlap, na.rm=TRUE))

```

```{r}
distance_df %>% 
  left_join(overlap_all, by=c("photo_no"="photo_no"))%>%
  mutate(time=as.POSIXct(time,format="%H:%M:%S")) %>% 
  ggplot(aes(time,forward_overlap)) + 
  geom_point(colour="darkblue")+
  geom_line(colour="darkblue")+
  facet_wrap(~Flight.x, scales = "free")

```

## Side overlap in m

```{r}
dfs_reduced=dfs_reduced %>% 
  rowwise() %>% 
  mutate("side_overlap"=side_overlap(altitude = alt_above_ground, banking_angle = banking_angle))

dfs_reduced %>%
  mutate(time=as.POSIXct(time,format="%H:%M:%S")) %>% 
  ggplot(aes(time,side_overlap)) + 
  geom_point(colour="darkblue")+
  geom_line(colour="darkblue")+
  facet_wrap(~Flight, scales = "free")

```

## Ground surface resolution in cm/pixel


```{r}
GSR_all_dfs=dfs_reduced %>% 
  rowwise() %>%mutate("GSD_near"=Kulan::GSD(altitude = alt_above_ground
                                 )[1])%>%  mutate("GSD_mid"=Kulan::GSD(altitude = alt_above_ground)[2]) %>% mutate("GSD_far"=Kulan::GSD(altitude = alt_above_ground)[3])
GSR_all_dfs %>% 
  group_by(Flight) %>% 
  summarise(cm_per_pixel_near=mean(unlist(GSD_near), na.rm=TRUE), sd_cm_per_pixel_near=sd(unlist(GSD_near), na.rm=TRUE),cm_per_pixel_far=mean(unlist(GSD_far), na.rm=TRUE), sd_cm_per_pixel_far=sd(unlist(GSD_far), na.rm=TRUE))

```

## Distance covered by each flight in KM

```{r}
(dist_sum=distance_df %>% 
  group_by(Flight) %>% 
  summarise(Distance=sum(coord_dif, na.rm=TRUE)))
```


## Generate summary ouputs

### Flight summary table 

```{r}

dfs_reduced<-dfs_reduced %>% inner_join(.,overlap_all)

dfs_reduced$Rel_for_over <- (dfs_reduced$forward_overlap/dfs_reduced$photo_area_R)*100  # add relative forward overlap

dfs_reduced<-dfs_reduced %>% inner_join(., GSR_all_dfs)

no_photos=dfs_reduced %>% 
  group_by(Flight) %>% 
  tally()

dfs_reduced<-dfs_reduced %>% inner_join(no_photos)


output_summary_table <- dfs_reduced %>% 
  group_by(Flight) %>% 
  summarise(Date=min(date), Time_start=min(time), Time_end=max(time), 
            Mean_Altitude=mean(alt_above_ground, na.rm=TRUE), #SD_Altitude=sd(alt_above_ground, na.rm=TRUE), 
            Mean_GPS_Speed=mean(gps_speed, na.rm=TRUE), #SD_GPS_Speed=sd(gps_speed, na.rm=TRUE),
            Mean_GPS_dist=mean(coord_dif, na.rm=TRUE), #SD_coord_dif=sd(coord_dif, na.rm=TRUE),
            Mean_Banking= mean(banking_angle, na.rm=TRUE), #SD_Banking=sd(banking_angle, na.rm=TRUE), 
            Mean_Stripw_right=mean(strip_width, na.rm=TRUE), #SD_Stripw_right=sd(strip_width, na.rm=TRUE),
            Mean_GSD_near=mean(unlist(GSD_near), na.rm=TRUE), Mean_GSD_mid=mean(unlist(GSD_mid), na.rm=TRUE), Mean_GSD_far=mean(unlist(GSD_far), na.rm=TRUE),
            Mean_Photo_area_R=mean(photo_area_R, na.rm=TRUE), #SD_Photo_area=sd(photo_area, na.rm=TRUE)
            Mean_Photo_area_L=mean(photo_area_L, na.rm=TRUE),#SD_Photo_area=sd(photo_area, na.rm=TRUE)
            Mean_side_overlap=mean(side_overlap, na.rm=TRUE), #SD_side_overlap=sd(side_overlap, na.rm=TRUE)) 
            Rel_side_overlap=(Mean_side_overlap/Mean_Stripw_right)*100, #% side overlap
            Mean_for_overlap=mean(forward_overlap, na.rm=TRUE), #SD_forward_overlap=sd(forward_overlap, na.rm=TRUE)) 
            Rel_for_overlap=(Mean_for_overlap/Mean_Photo_area_R)*100) #% forward overlap

no_photos <- dfs_reduced %>% 
  group_by(Flight) %>%
  tally()

names(no_photos)[2] <- "N_photos_right"

output_summary_table <- output_summary_table %>% 
                        inner_join(no_photos, by=c("Flight"="Flight"))

output_summary_table %>% view()
# You can write the table to .csv using this code below
#write.csv(output_summary_table, "Summary_per_Flight.csv")

```


```{r}
kableExtra::kable(output_summary_table) %>% 
  kableExtra::kable_styling()
```


